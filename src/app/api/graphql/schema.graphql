# GraphQL은 API 쿼리 언어입니다. REST API와 비교하면 클라이언트가 원하는 데이터만 선택해서 가져올 수 있다는 장점이 있습니다.
# GraphQL 쿼리 요청 → Prisma Client 호출 → 데이터베이스와 상호작용 → 결과 반환 → GraphQL 응답.

# 스키마(Schema): 클라이언트가 요청할 수 있는 데이터와 이를 처리하는 방법을 정의합니다. 이는 Java에서 Controller와 비슷한 역할을 합니다.
# 타입(Type): 데이터 구조를 정의합니다. Java의 DTO(Data Transfer Object)나 VO(Value Object)와 비슷합니다.
# 쿼리(Query): 클라이언트가 데이터를 조회할 때 사용하는 명령입니다. Java에서는 @GetMapping 메서드와 유사합니다.
# 뮤테이션(Mutation): 데이터를 변경하거나 생성할 때 사용하는 명령입니다. Java에서는 @PostMapping, @PutMapping과 유사합니다.

# Prisma 스키마에서 정의한 모델은 GraphQL 스키마의 타입과 직접 연결됩니다. Prisma ORM은 데이터베이스와 통신하며, GraphQL은 Prisma를 통해 데이터를 요청하거나 변경합니다.

# GraphQL에서 Post 타입은 Prisma에서 정의된 Post 모델의 구조를 반영합니다.
# likedByMe 필드는 Prisma 모델에 존재하지 않지만, GraphQL API에서 동적으로 추가한 필드입니다. Java에서 @Transient를 사용하여 데이터베이스에 저장되지 않는 값을 동적으로 계산하는 것과 비슷합니다.
# Prisma에서 다대다 관계(Post와 Category, Post와 Tag)는 GraphQL에서도 그대로 반영됩니다.
# GraphQL에서 [Category!]!는 배열이며, 각 요소가 Category 타입이고, null이 될 수 없는 필드를 의미합니다.
type Post {
    id: Int!
    title: String!
    content: String!
    createdAt: DateTime!
    updatedAt: DateTime!
    categories: [Category!]!
    tags: [Tag!]!
    likes: [Like!]!
    likedByMe: Boolean! # 현재 사용자의 좋아요 여부
}

# subscriberCount와 subscribedByMe는 각각 구독자 수와 현재 사용자의 구독 여부를 나타냅니다.
type Category {
    id: Int!
    name: String!
    posts: [Post!]!
    subscriberCount: Int!
    subscribedByMe: Boolean! # 현재 사용자의 구독 여부
}

# subscriberCount와 subscribedByMe는 각각 구독자 수와 현재 사용자의 구독 여부를 나타냅니다.
type Tag {
    id: Int!
    name: String!
    posts: [Post!]!
    subscriberCount: Int!
    subscribedByMe: Boolean! # 현재 사용자의 구독 여부
}

# Prisma에서는 다대다 관계를 관리하기 위해 연결 테이블을 사용하는데, GraphQL에서 이를 노출하지 않을 수도 있습니다.
# GraphQL에서 연결 테이블(Like)은 Prisma 모델에 정의된 것처럼 독립된 타입으로 노출됩니다.
# user와 post 필드는 User와 Post 타입을 참조합니다.
type Like {
    id: Int!
    post: Post!
    user: User!
    createdAt: DateTime!
}

type User {
    id: Int!
    name: String!
    email: String!
    likedPosts: [Post!]!
    categorySubscriptions: [Category!]!
    tagSubscriptions: [Tag!]!
}

# 게시글 목록을 가져오는 데 사용되는 입력값.
# 페이징 처리(limit, cursor) 및 필터링 옵션(includeCategories, includeTags, includeLiked)을 제공합니다.
# JPA에서는 PageRequest와 유사한 역할.
# Prisma에서는 findMany 메서드로 페이징 및 필터링을 지원합니다.
# limit은 가져올 데이터의 최대 개수를 설정합니다.
# cursor는 다음 페이지를 위한 기준점 역할을 합니다. (예: createdAt 필드의 마지막 값)
input FeedInput {
    includeCategories: Boolean
    includeTags: Boolean
    includeLiked: Boolean
    limit: Int
    cursor: String
}

type PageInfo {
    hasNextPage: Boolean!
    endCursor: String
}

type FeedResponse {
    posts: [Post!]!
    pageInfo: PageInfo!
}

type Query {
    feed(input: FeedInput): FeedResponse!
    post(id: Int!): Post
    categories: [Category!]!
    tags: [Tag!]!
}

# 특정 게시글의 좋아요 상태를 토글하거나, 카테고리/태그의 구독 상태를 변경합니다.
# JPA 기반에서는 Service 계층에서 비즈니스 로직으로 구현하는 부분에 해당합니다.
type Mutation {
    toggleLike(postId: Int!): Post!
    toggleCategorySubscription(categoryId: Int!): Category!
    toggleTagSubscription(tagId: Int!): Tag!
}

# GraphQL은 실시간 데이터를 제공하기 위해 Subscription을 제공합니다.
# onPostCreated: 새로운 게시글이 생성될 때마다 클라이언트가 실시간으로 알림을 받습니다.
# onPostLiked: 특정 게시글에 좋아요가 눌렸을 때 실시간 알림을 받습니다.
# Java에서는 WebSocket과 비슷한 역할을 하며, GraphQL에서는 표준으로 제공됩니다.
type Subscription {
    onPostCreated: Post!
    onPostLiked(postId: Int!): Post!
}

scalar DateTime
